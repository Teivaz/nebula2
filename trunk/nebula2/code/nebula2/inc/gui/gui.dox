/**
    @defgroup NebulaGuiSystem Graphical User Interface

    This section of the documentation covers the Nebula GUI system that 
    can be used to create an in-game graphical user interface.

    @section NebulaGuiSystemInitialize Initialization and Rendering

    The first thing for initialization of the GUI system is to specify the root path
    of the GUI system. This root path is where the created GUI widgets are live. 
    It can be done by calling nGuiServer::SetRootPath member function.
    If you do not explicitly set the root path, it will be set on @c'/res/gui' 
    by default. 
    And next, call nGuiServer::Open for initializing GUI system.

    @code
guiServer->SetRootPath("/gui")
guiServer->Open();
    @endcode
   
    nGuiServer::Open internally calls nScriptServer::RunScript and run the script
    @c'OnGuiServerOpen'. So @cOnGuiServerOpen script should be provided before
    nGuiServer::Open is called if you want to do some initial task for the GUI system.
    @c'OnGuiServerClose' script can be called on nGuiServer::Close in the same manner.

    Calling nGuiServer::Open internally create a default root window.
    A created window will be loacated under this root window. The name of root window
    which defaultly created by nGuiServer is @c'SystemRootWindow' and you can see this
    window is located under the root path.

    You can hide all windows by 0 to nGuiServer::SetRootWindow: 

    @code
guiServer->SetRootWindow(0);    
    @endcode

    or with the script form:

    @verbatim
/>sel /sys/servers/gui
/sys/servers/gui>.setrootwindow ""
    @endverbatim

    To render GUI windows, you should call nGuiServer::Trigger and nGuiServer::Render
    in rendering loop.

    @code
// render loop   
...
guiServer->Trigger();   
...
if (sceneServer->BeginScene(viewMatrix))
{
    ...
    sceneServer->EndScene();
    ...
    guiServer->Render();
    ...
    sceneServer->PresentScene();
}
    @endcode

    Do calling nGuiServer::Trigger like other Nebula servers. 
    Call nGuiServer::Render after rendering the scene. This will render windows
    and that will be shown on view.

    You should call nGusServer::Close when the application is closed.

    @code
guiServer->Close();   
    @endcode

    Lastly, release the GUI server by calling its Release() member function.

    @code
guiServer->Release(); 
    @endcode

    @section NebulaGuiSystemSkin Setting up Skin

    To use GUI system, you should create its skin first. 
    Usually it is good to create and define a skin onOnGuiServerOpen script.
    (see startup.tcl in the directory '$nebula2/bin/' for it's example)
    To do like that makes easy editable and changes of the defined skin.

    You can create a skin by calling nGuiServer::NewSkin with a given skin name.

    @code
// 'system' is skin name.
skin = guiServer->NewSkin("system");
    @endcode

    Then specify a path of the skin texture and its file extension.

    @code
skin->SetTexturePrefix("home:export/textures/system/");
skin->SetTexturePostfix(".dds");
    @endcode

    A Skin also need to be specifed its color when it is activate or 
    inactivate.

    @code
skin->SetActiveWindowColor(1.0, 1.0, 1.0, 0.9);
skin->SetInactiveWindowColor(0.6, 0.6, 0.6, 0.6);
    @endcode

    Finally, register brush to be used in the skin.
    @code
skin->BeginBrushes()
skin->AddBrush("titlebar", "skin",  0, 52, 43, 20, 1.0, 1.0, 1.0, 1.0)
skin->AddBrush("window",   "skin",  0, 77, 15, 13, 1.0, 1.0, 1.0, 1.0)
skin->EndBrushes()
    @endcode


    @section NebulaGuiSystemCreateWindow Creating a Window
 
    This section provides a brief example of creating a window on console 
    to make it easy to understand Nebula GUI system.

    You can create a window by calling nGuiServer::NewWindow with a given 
    class name.

    Run nviewer.exe and type this on it's colsole:

    @verbatim
/>sel /sys/servers/gui
/sys/servers/gui>.newwindow nguiclientwindow true
    @endverbatim

    or on C++:

    @code
guiServer->NewWindow("nguiclientwindow", true);
    @endcode
    
    Above code create a window of nGuiClientWindow type under the root window.
    ('SystemRootWindow' is the root window at this time)
    The name of created window is automatically assigned by nGuiServer when
    it is created by calling nGuiServer::NewWindow.
    The first window has @c'window0' for its name and the second
    has @c'window1'. All the next created windows will have it's name for this way.
   
    Created nGuiClientWindow type of window defaultly has Titlebar, CloseButton, 
    SizeButton and Layout element. 

    You can check this by typing @c'dir' command under created window:

    @verbatim
/gui/SystemRootWindow/window3>dir
TitleBar CloseButton SizeButton Layout
/gui/SystemRootWindow/window3>
    @endverbatim

    If you want to add a button or some other GUI elements for its child, 
    you should create those widget under the Layout.

    @verbatim
/gui/SystemRootWindow/window3>sel Layout
/gui/SystemRootWindow/window3/Layout>new nguibutton mybutton
/gui/SystemRootWindow/window3/Layout>sel mybutton
/gui/SystemRootWindow/window3/Layout/mybutton>.setdefaultbrush terminal_n
/gui/SystemRootWindow/window3/Layout/mybutton>.setpressedbrush terminal_p
/gui/SystemRootWindow/window3/Layout/mybutton>.sethighlightbrush terminal_h
/gui/SystemRootWindow/window3/Layout/mybutton>.settooltip test
/gui/SystemRootWindow/window3/Layout/mybutton>sel ..
/gui/SystemRootWindow/window3/Layout>.attachform mybutton left 0.0
/gui/SystemRootWindow/window3/Layout>.attachform mybutton top 0.0
/gui/SystemRootWindow/window3/Layout>.attachform mybutton bottom 0.0
/gui/SystemRootWindow/window3/Layout>.attachpos mybutton right 0.3
/gui/SystemRootWindow/window3/Layout>sel mybutton
/gui/SystemRootWindow/window3/Layout/mybutton>.show
    @endverbatim

    or on C++:

    @code
nGuiButton* btn;
btn = (nGuiButton*) kernelServer->New("nguibutton", "mybutton");

// the brushes terminal_n, terminal_p and terminal_h should be 
// aleady defined when a skin is created.
btn->SetDefaultBrush("terminal_n");
btn->SetPressedBrush("terminal_p");
btn->SetHighlightBrush("terminal_h");
btn->SetTooltip("Button Test");
layout->AttachForm(btn, nGuiFormLayout::Left, 0.0f);
layout->AttachForm(btn, nGuiFormLayout::Top, 0.0f);
layout->AttachForm(btn, nGuiFormLayout::Bottom, 0.0f);
// assume btnSize is 0.3
layout->AttachPos(btn, nGuiFormLayout::Right, 1 * btnSize);
btn->OnShow();
    @endcode

    nGuiButton and derives classes have three states for its state. 
    Normal, pressed and highlight are those.
    When the button is created, you should specify all those three states
    of the brush by calling nGuiButton::SetDefaultBrush, nGuiButton::SetPressedBrush 
    and nGuiButton::SetHighlightBrush.
    If you do not that, the button will be not shown on the window.

    nGuiFormLayout is used to provide flexible layout scheme.
    It provides relative positioning of child elements.
    The created 'mybutton' has its left, top and bottom edges aligned with the form.
    Its right edge is placed at 30% of the width of the form.

    Call 'show' command(or call nGuiButton::OnShow) on the button to apply the 
    changes.

*/
