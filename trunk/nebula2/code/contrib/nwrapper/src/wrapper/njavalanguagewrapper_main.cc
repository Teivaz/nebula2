//------------------------------------------------------------------------------
//  njavalanguagewrapper.cc
//  This file is licensed under the terms of the Nebula License.
//  (C) 2003 Bruce Mitchener, Jr.
//------------------------------------------------------------------------------
#include "wrapper/njavalanguagewrapper.h"

nNebulaClass(nJavaLanguageWrapper, "nlanguagewrapper");

static const char * translateArgToJavaType(nArg *);
static const char * translateArgToJNIType(nArg *);
static const char * translateArgToJNIRetValDecl(nArg *);
static const char * translateArgToJNIRetValGeneration(nArg *);
static void translateJNIValueToArg(nArg *, int, nString *);

//------------------------------------------------------------------------------
/**
*/
nJavaLanguageWrapper::nJavaLanguageWrapper()
{
    javaFile = new nFile(kernelServer->GetFileServer());
    headerFile = new nFile(kernelServer->GetFileServer());
    implFile = new nFile(kernelServer->GetFileServer());

    this->headerFile->Open("inc/java/nebulajava.h", "w");
    this->implFile->Open("src/java/nebulajava.cc", "w");
    n_assert(this->headerFile->IsOpen());
    n_assert(this->implFile->IsOpen());

    this->headerFile->PutS("/* DO NOT EDIT THIS FILE - it is machine generated */\n\n");
    this->headerFile->PutS("#include <jni.h>\n");
    this->headerFile->PutS("#ifndef _NEBULA_JAVA_H\n");
    this->headerFile->PutS("#define _NEBULA_JAVA_H\n");
    this->headerFile->PutS("#ifdef __cplusplus\n");
    this->headerFile->PutS("extern \"C\" {\n");
    this->headerFile->PutS("#endif\n");
    this->headerFile->PutS("\n");

    this->implFile->PutS("/* DO NOT EDIT THIS FILE - it is machine generated */\n\n");
    this->implFile->PutS("#include \"java/nebulajava.h\"\n");
    this->implFile->PutS("#include \"kernel/nclass.h\"\n");
    this->implFile->PutS("#include \"kernel/ncmd.h\"\n");
    this->implFile->PutS("#include \"kernel/nkernelserver.h\"\n");
    this->implFile->PutS("#include \"kernel/nroot.h\"\n");
    this->implFile->PutS("#include \"java/njavautils.h\"\n");
    this->implFile->PutS("\n");
}

//------------------------------------------------------------------------------
/**
*/
nJavaLanguageWrapper::~nJavaLanguageWrapper()
{
    if (true == this->javaFile->IsOpen())
    {
        this->javaFile->Close();
    }
    this->headerFile->PutS("#ifdef __cplusplus\n");
    this->headerFile->PutS("}\n");
    this->headerFile->PutS("#endif\n");
    this->headerFile->PutS("#endif\n");
    this->headerFile->Close();
    this->implFile->Close();

    this->javaFile->Release();
    this->headerFile->Release();
    this->implFile->Release();
}

//------------------------------------------------------------------------------
/**
*/
void
nJavaLanguageWrapper::OpenClass(nClass * cl)
{
    n_printf("Generating code for %s...", cl->GetProperName());

    nString fileName;
    fileName = "src/java/org/cubik/nebuladevice/";
    fileName += cl->GetProperName();
    fileName += ".java";
    this->javaFile->Open(fileName.Get(), "w");
    n_assert(this->javaFile->IsOpen());

    this->javaFile->PutS("/* DO NOT EDIT THIS FILE - it is machine generated */\n\n");
    this->javaFile->PutS("package org.cubik.nebuladevice;\n\n");
    nString classDef = "public class ";
    classDef += cl->GetProperName();
    if (NULL != cl->GetSuperClass())
    {
        classDef += " extends ";
        classDef += cl->GetSuperClass()->GetProperName();
    }
    classDef += " {\n";
    this->javaFile->PutS(classDef.Get());
    nString constructor;
    constructor = "    public ";
    constructor += cl->GetProperName();
    constructor += "() {\n";
    constructor += "    }\n";
    this->javaFile->PutS(constructor.Get());
    this->javaFile->PutS("\n");
    constructor = "    public ";
    constructor += cl->GetProperName();
    constructor += "(String name) {\n";
    constructor += "        nohName = name;\n";
    constructor += "    }\n";
    this->javaFile->PutS(constructor.Get());
    this->javaFile->PutS("\n");
}

//------------------------------------------------------------------------------
/**
*/
void
nJavaLanguageWrapper::CloseClass(nClass * cl)
{
    const char * className = cl->GetProperName();
    if (0 == strcmp(className, "nRoot")) {
        this->javaFile->PutS("\n");
        this->javaFile->PutS("    public String nohName;\n");
    }
    this->javaFile->PutS("};\n");
    this->javaFile->Close();

    n_printf(" Done.\n");
}

//------------------------------------------------------------------------------
/**
*/
void
nJavaLanguageWrapper::WriteCommand(nClass * cl, nCmdProto * cmdProto)
{
    nString javaString;
    nString headerString;
    nString implString;

    javaString += "    public native ";
    headerString  = "/*\n";
    headerString += " * Class:     ";
    headerString += cl->GetProperName();
    headerString += "\n";
    headerString += " * Method:    ";
    headerString += cmdProto->GetName();
    headerString += "\n";
    headerString += " * Signature: ...";
    headerString += "\n";
    headerString += " */\n";
    headerString += "JNIEXPORT ";
    implString += "JNIEXPORT ";

    nCmd * cmd = cmdProto->NewCmd();
    nArg * outArg = NULL;
    if (0 == cmdProto->GetNumOutArgs())
    {
        javaString += "void";
        headerString += "void";
        implString += "void";
    }
    else if (1 < cmdProto->GetNumOutArgs())
    {
        this->javaFile->PutS("    // XXX: Missing multi-value return!\n");
        javaString += "void";
        headerString += "void";
        implString += "void";
    }
    else
    {
        int outArgIndex;
        for (outArgIndex = 0;
             outArgIndex < cmdProto->GetNumOutArgs();
             outArgIndex++)
        {
            outArg = cmd->Out();
            javaString += translateArgToJavaType(outArg);
            headerString += translateArgToJNIType(outArg);
            implString += translateArgToJNIType(outArg);
            if (nArg::List == outArg->GetType())
            {
                javaString += "[]";
            }
        }
    }
    javaString += " ";
    javaString += cmdProto->GetName();
    javaString += "(";
    headerString += " JNICALL";
    headerString += " Java_org_cubik_nebuladevice_";
    headerString += cl->GetProperName();
    headerString += "_";
    headerString += cmdProto->GetName();
    headerString += "(JNIEnv *, jobject";
    implString += " JNICALL\n";
    implString += "Java_org_cubik_nebuladevice_";
    implString += cl->GetProperName();
    implString += "_";
    implString += cmdProto->GetName();
    implString += "(JNIEnv * env, jobject obj";
    int inArgIndex; 
    for (inArgIndex = 0; inArgIndex < cmdProto->GetNumInArgs(); inArgIndex++)
    {   
        if (0 == inArgIndex)
        {
            headerString += ", ";
            implString += ", ";
        }
        nArg * inArg = cmd->In();
        javaString += translateArgToJavaType(inArg);
        headerString += translateArgToJNIType(inArg);
        implString += translateArgToJNIType(inArg);
        char buf[10];
        sprintf(buf, " arg%d", inArgIndex);
        javaString += buf;
        implString += buf;
        if (nArg::List == inArg->GetType())
        {
            javaString += "[]";
        }
        if (inArgIndex < (cmdProto->GetNumInArgs() - 1))
        {
            javaString += ", ";
            headerString += ", ";
            implString += ", ";
        }
    }

    javaString += ");\n";
    headerString += ");\n\n";
    implString += ")\n";
    implString += "{\n";
    implString += "    nKernelServer * kernelServer = nKernelServer::ks;\n";
    implString += "    if (!kernelServer) { quickInit(); kernelServer = nKernelServer::ks; }\n";
    nString returnString;
    if (1 == cmdProto->GetNumOutArgs())
    {
        implString += "    ";
        implString += translateArgToJNIRetValDecl(outArg);
        returnString = "return retVal;\n";
    }
    else if (1 < cmdProto->GetNumOutArgs())
    {
        // implString += "    jobjectArray retVal = NULL;";
        // returnString = "return retVal;\n";
        // For now, we don't properly support multi-value returns at all.
        returnString = "return;\n";
    }
    else
    {
        returnString = "return;\n";
    }
    implString += "    nRoot * nobj = unwrapJavaObject(env, obj);\n";
    implString += "    if (NULL == nobj)\n";
    implString += "    {\n";
    implString += "        " + returnString;
    implString += "    }\n";
    implString += "    \n";
    char buf[255];
    sprintf(buf, "    int fourcc = %d;\n", cmdProto->GetId());
    implString += buf;
    implString += "    nClass * ncls = kernelServer->FindClass(\"";
    implString += cl->GetName();
    implString += "\");\n";
    implString += "    nCmdProto * cmdProto = ncls->FindCmdById(fourcc);\n";
    implString += "    if (cmdProto)\n";
    implString += "    {\n";
    implString += "        nCmd* cmd = cmdProto->NewCmd();\n";
    implString += "        n_assert(cmd);\n";
    implString += "        \n";
    if (0 != cmdProto->GetNumInArgs())
    {
        cmd->Rewind();
        for (inArgIndex = 0; inArgIndex < cmdProto->GetNumInArgs(); inArgIndex++)
        {  
            nArg * inArg = cmd->In();
            nString translationLine;
            translateJNIValueToArg(inArg, inArgIndex, &translationLine);
            implString += "        " + translationLine;
        }
        implString += "\n";
    }
    implString += "        bool success = nobj->Dispatch(cmd);\n";
    implString += "        if (!success)\n";
    implString += "        {\n";
    implString += "            " + returnString;
    implString += "        }\n";
    implString += "        cmd->Rewind();\n";
    // For now, don't do anything here if outArg is NULL.
    if ((0 != cmdProto->GetNumOutArgs()) && (NULL != outArg))
    {
        implString += "        retVal = ";
        implString += translateArgToJNIRetValGeneration(outArg);
        implString += ";\n";
    }
    implString += "        cmdProto->RelCmd(cmd);\n";
    implString += "    }\n";
    implString += "    else\n";
    implString += "    {\n";
    implString += "        " + returnString;
    implString += "    }\n";
    implString += "    \n";
    implString += "    " + returnString;
    implString += "}\n\n";

    cmd->Rewind();
    cmdProto->RelCmd(cmd);

    this->javaFile->PutS(javaString.Get());
    this->headerFile->PutS(headerString.Get());
    this->implFile->PutS(implString.Get());
}

//------------------------------------------------------------------------------
/**
*/
static
const char *
translateArgToJavaType(nArg * arg)
{
    nArg::Type type = arg->GetType();
    switch (type)
    {
        case nArg::Void:
            return "void";
        case nArg::Int:
            return "int";
        case nArg::Float:
            return "float";
        case nArg::String:
            return "String";
        case nArg::Bool:
            return "boolean";
        case nArg::Object:
            return "Object";
        case nArg::List:
            return "Object";
        default:
            n_error("Unsupported arg type: %d\n", type);
    }
    return "";
}

//------------------------------------------------------------------------------
/**
*/
static
const char *
translateArgToJNIType(nArg * arg)
{
    nArg::Type type = arg->GetType();
    switch (type)
    {
        case nArg::Void:
            return "void";
        case nArg::Int:
            return "jint";
        case nArg::Float:
            return "jfloat";
        case nArg::String:
            return "jstring";
        case nArg::Bool:
            return "jboolean";
        case nArg::Object:
            return "jobject";
        case nArg::List:
            return "jobjectArray";
        default:
            n_error("Unsupported arg type: %d\n", type);
    }
    return "";
}

//------------------------------------------------------------------------------
/**
*/
static
const char *
translateArgToJNIRetValDecl(nArg * arg)
{
    nArg::Type type = arg->GetType();
    switch (type)
    {
        case nArg::Int:
            return "jint retVal = 0;\n";
        case nArg::Float:
            return "jfloat retVal = 0.0;\n";
        case nArg::String:
            return "jstring retVal = NULL;\n";
        case nArg::Bool:
            return "jboolean retVal = false;\n";
        case nArg::Object:
            return "jobject retVal = NULL;\n";
        case nArg::List:
            return "jobjectArray retVal = NULL;\n";
        default:
            n_error("Unsupported arg type: %d\n", type);
    }
    return "";
}

//------------------------------------------------------------------------------
/**
*/
static
const char *
translateArgToJNIRetValGeneration(nArg * arg)
{
    nArg::Type type = arg->GetType();
    switch (type)
    {
        case nArg::Int:
            return "(jint)cmd->Out()->GetI()";
        case nArg::Float:
            return "(jfloat)cmd->Out()->GetF()";
        case nArg::String:
            return "(jstring)env->NewStringUTF(cmd->Out()->GetS())";
        case nArg::Bool:
            return "(jboolean)cmd->Out()->GetB()";
        case nArg::Object:
            return "wrapNebulaObject(env, (nRoot *)(cmd->Out()->GetO()))";
        case nArg::List:
            return "wrapNebulaArgList(env, cmd->Out())";
        default:
            n_error("Unsupported arg type: %d\n", type);
    }
    return "";
}

//------------------------------------------------------------------------------
/**
*/
static
void
translateJNIValueToArg(nArg * arg, int argNum, nString * translationLine)
{
    char theTranslation[255], * theTranslationTemplate;
    nArg::Type type = arg->GetType();
    switch (type)
    {
        case nArg::Int:
            theTranslationTemplate = "cmd->In()->SetI(arg%d);\n";
            break;
        case nArg::Float:
            theTranslationTemplate = "cmd->In()->SetF(arg%d);\n";
            break;
        case nArg::String:
            theTranslationTemplate = "setArgFromJavaString(env, cmd->In(), arg%d);\n";
            break;
        case nArg::Bool:
            theTranslationTemplate = "cmd->In()->SetB((bool)arg%d);\n";
            break;
        case nArg::Object:
            theTranslationTemplate = "cmd->In()->SetO(unwrapJavaObject(env, arg%d));\n";
            break;
        case nArg::List:
            n_error("List arg types not supported as in args");
            break;
        default:
            n_error("Unsupported in arg type: %d\n", type);
            break;
    }
    sprintf(theTranslation, theTranslationTemplate, argNum);
    translationLine->Set(theTranslation);
}

