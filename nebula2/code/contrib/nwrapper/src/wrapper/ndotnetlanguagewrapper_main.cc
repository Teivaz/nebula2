//------------------------------------------------------------------------------
//  ndotnetlanguagewrapper.cc
//  This file is licensed under the terms of the Nebula License.
//  (C) 2003 Alton Goerby aka PerfectCell.
//------------------------------------------------------------------------------
#include <vector>
#include "wrapper/ndotnetlanguagewrapper.h"
nNebulaClass(nDotNetLanguageWrapper, "nlanguagewrapper");
static const char* TranslateArgToCSharpType(nArg*);

nDotNetLanguageWrapper::nDotNetLanguageWrapper():
csharpFile(kernelServer->GetFileServer())
{
}

nDotNetLanguageWrapper::~nDotNetLanguageWrapper()
{
    if(this->csharpFile.IsOpen()) this->csharpFile.Close();
    nString fileName;
    fileName = "src/dotnet/Nebula2/_util_.cs";
    this->csharpFile.Open(fileName.Get(), "w");
    n_assert(this->csharpFile.IsOpen());
    this->csharpFile.PutS("/* DO NOT EDIT THIS FILE - it is machine generated */\n\n");
    this->csharpFile.PutS("using System;\n");//using
    this->csharpFile.PutS("using System.Collections;\n\n");
    this->csharpFile.PutS("namespace Nebula2\n{\n");//namespace
    this->csharpFile.PutS("\tpublic class Util\n\t{\n");//class
    this->csharpFile.PutS("\t\tstatic Util()\n\t\t{\n");//static ctor
    nString content = "\t\t\tHashtable h = new Hashtable(";
    char buf[16];
    sprintf(buf, "%d", this->classNames.size());
    content += buf;
    content += ");\n";
    for(int i = 0; i < this->classNames.size(); i++)
    {
        content += "\t\t\th.Add(\"";
        content += this->classNames[i].Get();
        content += "\", Activator.CreateInstance(Type.GetType(\"Nebula2.";
        content += this->classNames[i].Get();
        content += "\"), true));\n";
    }
    content += "\t\t\tNebula2.NebulaObject.Table = h;\n";
    this->csharpFile.PutS(content.Get());
    this->csharpFile.PutS("\t\t}\n\n");//close ctor
    this->csharpFile.PutS("\t\tstatic public void CallMe(){}\n");//CallMe!
    this->csharpFile.PutS("\t}\n");//close class
    this->csharpFile.PutS("}");//close namespace
    this->csharpFile.Close();

}

void
nDotNetLanguageWrapper::OpenClass(nClass * cl)
{
    nString fileName;
    fileName = "src/dotnet/Nebula2/";
    fileName += cl->GetName();
    fileName += ".cs";
    this->csharpFile.Open(fileName.Get(), "w");
    n_assert(this->csharpFile.IsOpen());

    this->csharpFile.PutS("/* DO NOT EDIT THIS FILE - it is machine generated */\n\n");
    this->csharpFile.PutS("using System;\n\n");//using
    this->csharpFile.PutS("namespace Nebula2\n{\n");//namespace
    nString classDef = "\tpublic class ";
    classDef += cl->GetName();
    classDef += " : ";
    if(0 != cl->GetSuperClass())
        classDef += cl->GetSuperClass()->GetName();
    else
        classDef += "NebulaObject";

    classDef += "\n";
    classDef += "\t{\n";
    this->csharpFile.PutS(classDef.Get());
    nString constructor;
    constructor = "\t\tprotected ";//private ctor
    constructor += cl->GetName();
    constructor += "()\n\t\t{\n\t\t}\n";
    this->csharpFile.PutS(constructor.Get());
    this->csharpFile.PutS("\n");
    constructor = "\t\tpublic ";//public ctor
    constructor += cl->GetName();
    constructor += "(string name) : \n\t\t\tbase(name)\n\t\t{\n";
    if(cl->GetSuperClass() == 0)
        constructor += "\t\t\tUtil.CallMe();\n";
    constructor += "\t\t}\n";
    this->csharpFile.PutS(constructor.Get());
    this->csharpFile.PutS("\n");
    this->classNames.push_back((*new nString(cl->GetName())));
}

//------------------------------------------------------------------------------
/**
*/
void
nDotNetLanguageWrapper::CloseClass(nClass * cl)
{
    this->csharpFile.PutS("\t}\n"); //close class
    this->csharpFile.PutS("}"); //close namespace
    this->csharpFile.Close();
}

//------------------------------------------------------------------------------
/**
*/
void
nDotNetLanguageWrapper::WriteCommand(nClass * cl, nCmdProto * cmdProto)
{
    nString mheadString; //mehtod header
    nString mbodyString; //method body

    mheadString += "\t\tpublic ";
    nString retType;
    nCmd * cmd = cmdProto->NewCmd();
    if(cmdProto->GetNumOutArgs() == 0)
    {
        mheadString += "void";
    }
    else if(cmdProto->GetNumOutArgs() == 1)
    {
        nString s = TranslateArgToCSharpType(cmd->Out());
        mheadString += s;
        retType = s;
    }
    else
    {
       mheadString += "object[]";
       retType = "object[]";
    }
    mheadString += " ";
    mheadString += cmdProto->GetName();
    mheadString += "(";

    nString argNames;
    for(int i = 0; i < cmdProto->GetNumInArgs(); i++)
    {   
        mheadString.Append(TranslateArgToCSharpType(cmd->In()));
        char buf[16];

        sprintf(buf, " arg%d", i);
        if(i == 0)
            argNames += ",";

        mheadString += buf;
        argNames += buf;
        if(i < (cmdProto->GetNumInArgs() - 1))
        {
            mheadString += ", ";
            argNames += ", ";
        }
    }

    mheadString += ")";

    //const uint fourcc = nnnnnnnnnn;
    char buf[32];
    sprintf(buf, "%d;\n", cmdProto->GetId());
    mbodyString += "\t\t\tconst uint fourcc = ";
    mbodyString += buf;
    mbodyString += "\t\t\t";
    if(cmdProto->GetNumOutArgs() > 0)
        mbodyString += retType+" ret = ("+retType+")";
    //Util.InvokeNebulaCmd(arg0, ..., argn);
    mbodyString += "this.InvokeNebulaCmd(fourcc"+argNames+");";
    
    //return ret;
    if(cmdProto->GetNumOutArgs() > 0)
        mbodyString += "\n\t\t\treturn ret;";

    cmd->Rewind();
    cmdProto->RelCmd(cmd);

    this->csharpFile.PutS(mheadString.Get());
    this->csharpFile.PutS("\n\t\t{\n");
    this->csharpFile.PutS(mbodyString.Get());
    this->csharpFile.PutS("\n\t\t}\n\n");
}

//------------------------------------------------------------------------------
/**
*/
static const char* TranslateArgToCSharpType(nArg* arg)
{
    nArg::ArgType type = arg->GetType();
    switch(type)
    {
        case nArg::ARGTYPE_VOID:
            return "void";
        case nArg::ARGTYPE_INT:
            return "int";
        case nArg::ARGTYPE_FLOAT:
            return "float";
        case nArg::ARGTYPE_STRING:
            return "string";
        case nArg::ARGTYPE_BOOL:
            return "bool";
        case nArg::ARGTYPE_OBJECT:
            return "object";
        case nArg::ARGTYPE_CODE:
            return "code";
        case nArg::ARGTYPE_LIST:
            return "object[]";
    }
    return "";
}