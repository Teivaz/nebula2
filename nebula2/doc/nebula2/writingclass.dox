/**
    @page NebulaWritingClass Writing A New nRoot Derived Class

    This page describes how to create nRoot derived classes, that is classes 
    that have nRoot somewhere in their ancestry. Instances of a nRoot derived 
    class are placed in the Named Object Hierarchy (NOH) [@b FIXME: Need to link 
    to page describing NOH], so each instance is a node in a tree structure with 
    a path name like @c /sys/servers/gfx. nRoot derived classes can also have 
    script commands that can be called from script and used for object 
    persistence.

    First, we create a header file, @c nmyclass.h and write a class which 
    derives from nRoot. We will later bind some of the methods to the script 
    interface so that they can be called from script.

    @code
    class nMyClass : public nRoot
    {
    public:
        nMyClass();
        virtual ~nMyClass();

        int DoJob(char* str);

        void SetFoo(bool b);
        bool GetFoo() const;
    };
    @endcode

    Next, we create a implementation file @c nmyclass_main.cc.
    
    @code
    #include "mypackage/nmyclass.h"
  
    nNebulaScriptClass(nMyClass, "nroot");
    @endcode

    nNebulaScriptClass is a macro that sets up the class to be used for 
    scripting and in the NOH. There are a few different versions of this macro 
    (see ndefclass.h), the most commonly used are:
    
        @li nNebulaClass Use for classes that don't have any script commands.
        @li nNebulaScriptClass Use for classes that will have script commands.

    Every nRoot derived class must use one of these macros.
    
    We also define a constructor and destructor for @c nMyClass.

    @code
    // constructor.
    nMyClass::nMyClass()
    {
    }

    // destructor.
    nMyClass::~nMyClass()
    {
    }
    @endcode

    @warning Because nRoot derived classes are created by the nKernelServer, 
    they can only have the default destructor.

    Next we make the script and persistence interface. The script commands are 
    put in their own file which should have be named @c <classname>_cmds.cc, in 
    this case we call the file @c nmyclass_cmds.cc.

    The first thing we do is declare static functions for each script command. 
    Then we define a function @c n_initcmds(). This function is used to bind the 
    static functions to each script command.
    
    The function which we want to make scriptable is @c nMyClass::DoJob().

    @code
    // callback function declaration.
    static void n_dojob(void* slf, nCmd* cmd);
    ...

    void n_initcmds(nClass* cl)
    {
        cl->BeginCmds();

        // register script command.
        cl->AddCmds("i_dojob_s",  'DOJB', n_dojob);
        cl->AddCmds("v_setfoo_b", 'SETF', n_setfoo);
        cl->AddCmds("b_getfoo_v", 'GETF', n_getfoo);

        cl->EndCmds();
    }
    ...
    @endcode

    The AddCmds() function takes 3 arguments, the first is a string describing 
    the command name and the number of in-arguments and out-arguments. In the 
    case of @c dojob, it takes a single string in-argument and returns a single 
    integer out-argument. The basic structure of the command name is:
    
    @verbatim
    <out-argument-list>_<command-name>_<in-argument-list>
    @endverbatim    
    
    The codes for the argument types are:
    
      - v : void type
      - i : integer type
      - f : float type
      - s : string type
      - b : bool type
      - o : object type
    
    You can use anything for the @c command-name but the method name is 
    prefered. The second arguement to AddCmds() @c 'DOJB' is internal identifier 
    for this script command. You can use any four characters but you must ensure that
    the identifier is unique for this class [FIXME: and all ancestor classes?].

    The last argument to AddCmds() is the static function that will handle this script
    comand.

    Now we define the script command's function.

    @code
    static void n_dojob(void* slf, nCmd* cmd)
    {
        // get in-argument. 
        char* inArg = cmd->In()->GetS();

        // call nMyClass::DoJob.
        int ret = slf->DoJob(inArg);

        // pass out-argument out.
        cmd->Out()->SetI(ret);
    }
    @endcode

    The first argument of callback function is class instance which the 
    script command belong to, so this is nMyClass class instance. 
    The second argument is in and out arguments for this script
    command. Recall the arguments of nMyClass::DoJob(), which has one integer
    type of out-argument and one string type of arguement. We can easily
    get those argument by interfaces of nCmd. Call nCmd::In() for in-argument and
    nCmd::Out() for out-argument.

    Next, we make nMyClass to support object persistence.

    To make the class to support object persistency, we override SaveCmds().
    
    Declare SaveCmds of nMyClass in header file like this:

    @code
    class nMyClass : public nRoot
    {
    public:
    ...
        bool SaveCmds(nPersistServer* ps);
    ...
    };
    @endcode

    Define nMyClass::SaveCmds() function in 'nmyclass_cmds.cc' implementation 
    file like this:

    @code
    bool nMyClass::SaveCmds(nPersistServer* ps)   
    {
        ...

        nCmd* cmd;

        cmd = ps->GetCmd(this, 'SETF');
        cmd->In()->SetB(this->foo);
        ps->PutCmd(cmd);

        ...
    }
    @endcode

    Things to do for object persistence is: 
    
      - Get command from nPersistServer by calling GetCmd(). 
      - Pass appropriate argument for this command
      - Put command back to nPersistServer.

    That's all for object persistence. Now the object of nMyClass will be
    saved out to script file whenever you call 'save' or 'saveas' in console
    or script.

    There are bunch of sources which give you more clear understand.

    @see
    nTransformNode and nShapeNode for working code.

*/
